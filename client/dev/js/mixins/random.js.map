{"version":3,"sources":["../../es6/mixins/random.js"],"names":[],"mappings":";;AAAA,CAAC,CAAC,MAAM,GAAG,AAAC,YAAM;AAChB,MAAI,MAAM,GAAG,SAAT,MAAM,CAAY,GAAG,EAAE,GAAG,EAAE;AAC9B,QAAI,IAAI,GAAG,CAAC,CAAC;AACb,QAAI,KAAK,GAAG,GAAG,GAAG,GAAG,CAAC;;AAEtB,QAAI,WAAW,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;AACzE,QAAI,WAAW,GAAG,EAAE,EAAE;AACpB,YAAM,IAAI,IAAI,CAAC,SAAS,CAAC,iDAAiD,CAAC,CAAC;KAC7E;AACD,QAAI,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;AAC9C,QAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,CAAC,GAAG,CAAC;;;;AAAC,AAIxC,QAAI,SAAS,GAAG,IAAI,UAAU,CAAC,YAAY,CAAC,CAAC;AAC7C,QAAI,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;;AAEvC,QAAI,CAAC,GAAG,CAAC,YAAY,GAAG,CAAC,CAAA,GAAI,CAAC,CAAC;AAC/B,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;AACrC,UAAI,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,OAAC,IAAI,CAAC,CAAC;KACR;;;AAAA,AAGD,QAAI,GAAG,IAAI,GAAG,IAAI,CAAC;;AAEnB,QAAI,IAAI,IAAI,KAAK,EAAE;;AAEjB,aAAO,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;KACzB;;AAAA,AAED,WAAO,GAAG,GAAG,IAAI,CAAC;GACnB,CAAC;AACF,SAAO,YAAM;AACX,WAAO,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC,GAAG,UAAU,CAAC;GAC3C,CAAC;CACH,EAAG,CAAC;;AAEL,CAAC,CAAC,WAAW,GAAG,UAAS,GAAG,EAAE,GAAG,EAAE;AACjC,SAAQ,AAAE,GAAG,GAAG,CAAC,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,CAAA,AAAC,GAAG,CAAC,CAAE;CACnD,CAAC;;AAEF,CAAC,CAAC,IAAI,GAAG,YAAW;AAClB,SAAO,sCAAsC,CAAC,OAAO,CAAC,OAAO,EAAE,UAAS,CAAC,EAAE;AACzE,QAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;QACvB,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,GAAI,CAAC,GAAG,GAAG,GAAG,GAAG,AAAC,CAAC;AACvC,WAAO,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;GACvB,CAAC,CAAC;CACJ,CAAC","file":"random.js","sourcesContent":["R.random = (() => {\n  var random = function(min, max) {\n    var rval = 0;\n    var range = max - min;\n    \n    var bits_needed = R.exists(Math.log2) ? Math.ceil(Math.log2(range)) : 30;\n    if (bits_needed > 53) {\n      throw new self.Exception('We cannot generate numbers larger than 53 bits.');\n    }\n    var bytes_needed = Math.ceil(bits_needed / 8);\n    var mask = Math.pow(2, bits_needed) - 1;\n    // 7776 -> (2^13 = 8192) -1 == 8191 or 0x00001111 11111111\n    \n    // Create byte array and fill with N random numbers\n    var byteArray = new Uint8Array(bytes_needed);\n    self.crypto.getRandomValues(byteArray);\n    \n    var p = (bytes_needed - 1) * 8;\n    for (var i = 0; i < bytes_needed; i++) {\n      rval += byteArray[i] * Math.pow(2, p);\n      p -= 8;\n    }\n    \n    // Use & to apply the mask and reduce the number of recursive lookups\n    rval = rval & mask;\n    \n    if (rval >= range) {\n      // Integer out of acceptable range\n      return random(min, max);\n    }\n    // Return an integer that falls within the range\n    return min + rval;\n  };\n  return () => {\n    return random(0, 1000000000) / 1000000000;\n  };\n})();\n\nR.randomRange = function(min, max) {\n  return (( min + R.random() * (max - min + 1) )|0);\n};\n\nR.guid = function() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = R.random() * 16 | 0,\n        v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n};\n"]}