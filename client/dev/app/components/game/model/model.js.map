{"version":3,"sources":["model.es6"],"names":[],"mappings":";;AAAA,CAAC,YAAW;AACV,UAAQ,MAAR,CAAe,qBAAf,EACG,SADH,CACa,gBADb,EAC+B,yBAD/B,EAEG,SAFH,CAEa,qBAFb,EAEoC,8BAFpC,EADU;;AAKV,4BAA0B,OAA1B,GAAoC,CAClC,UADkC,EAElC,SAFkC,EAGlC,cAHkC,EAIlC,OAJkC;;AAMlC,sBANkC,CAApC,CALU;;;;;;;;;;;;;AAwBV,WAAS,yBAAT,CACE,eADF,EAEE,cAFF,EAGE,iBAHF,EAIE,UAJF;;AAME;;;;;;;;;;;;AANF,IAkBE;AACA,QAAM,0BAA0B;AAC9B,gBAAU,GAAV;AACA,YAAM,IAAN;KAFI,CADN;AAKA,WAAO,uBAAP,CALA;;AAOA,aAAS,IAAT,CAAc,KAAd,EAAqB,QAArB,EAA+B;AAC7B,UAAM,QAAQ,MAAM,KAAN,CADe;AAE7B,UAAM,QAAQ,MAAM,KAAN,CAFe;AAG7B,UAAM,OAAO,EAAE,MAAF,CAAS,MAAM,QAAN,CAAT,CACX,kBAAkB,aAAlB,CAAgC,MAAM,KAAN,CAAY,IAAZ,CADrB,EAEX,EAAE,SAAF,CAAY,EAAE,aAAa,KAAb,EAAd,CAFW,CAAP,CAHuB;AAO7B,cAAQ,GAAR,CAAY,WAAZ,EAAyB,MAAM,KAAN,EAAa,IAAtC,EAP6B;;AAS7B,YAAM,kBAAN,CAAyB,mBAAzB,EAA8C,QAA9C,EAAwD,KAAxD,EAT6B;AAU7B,YAAM,kBAAN,CAAyB,oBAAzB,EAA+C,QAA/C,EAAyD,KAAzD,EAV6B;AAW7B,YAAM,kBAAN,CAAyB,6BAAzB,EAAwD,QAAxD,EAAkE,KAAlE,EAX6B;AAY7B,YAAM,kBAAN,wBAA8C,MAAM,KAAN,CAAY,KAAZ,EACrB,SADzB,EACoC,KADpC,EAZ6B;AAc7B,kBAAY,KAAZ,EAd6B;;AAgB7B,UAAI,kBAAJ,CAhB6B;AAiB7B,UAAI,sBAAJ,CAjB6B;AAkB7B,UAAI,uBAAJ,CAlB6B;AAmB7B,eAAS,QAAT,GAAoB;AAClB,YAAM,MAAM,SAAS,cAAT,CAAwB,KAAxB,CAAN,CADY;AAElB,YAAM,aAAa,eAAe,SAAf,CAAyB,GAAzB,CAAb,CAFY;AAGlB,YAAM,QAAQ,gBAAgB,OAAhB,EAAR,CAHY;AAIlB,YAAM,YAAY,EAAE,IAAF,CAAO,CAAC,MAAD,EAAQ,iBAAR,CAAP,EAAmC,KAAnC,CAAZ,CAJY;AAKlB,YAAM,QAAQ,MAAM,KAAN,CALI;AAMlB,YAAG,WAAW,KAAX,IACA,eAAe,SAAf,IACA,gBAAgB,UAAhB,EAA4B;AAC7B,iBAD6B;SAF/B;AAKA,iBAAS,KAAT,CAXkB;AAYlB,qBAAa,SAAb,CAZkB;AAalB,sBAAc,UAAd,CAbkB;;AAelB,oBAfkB;OAApB;AAiBA,eAAS,SAAT,GAAqB;AACnB,oBAAY,KAAZ,EADmB;AAEnB,cAAM,OAAN,GAFmB;OAArB;KApCF;AAyCA,aAAS,WAAT,CAAqB,KAArB,EAA4B;AAC1B,UAAM,MAAM,SAAS,cAAT,CAAwB,KAAxB,CAAN,CADoB;AAE1B,UAAM,aAAa,eAAe,SAAf,CAAyB,GAAzB,CAAb,CAFoB;AAG1B,UAAM,QAAQ,MAAM,KAAN,CAHY;;AAK1B,UAAM,QAAQ,gBAAgB,OAAhB,EAAR,CALoB;AAM1B,YAAM,MAAN,GAAe,WACZ,MADY,CACL,UADK,EACO,MAAM,QAAN,EAAgB,MAAM,KAAN,CADtC,CAN0B;;AAS1B,UAAM,YAAY,EAAE,IAAF,CAAO,CAAC,MAAD,EAAQ,iBAAR,CAAP,EAAmC,KAAnC,CAAZ,CAToB;AAU1B,UAAM,QAAQ,MAAM,KAAN,CAAY,KAAZ,CAVY;AAW1B,UAAM,QAAQ,wBACL,EADK,CACF,OADE,EACO,KADP,EACc,SADd,CAAR,CAXoB;AAa1B,UAAM,SAAS,wBACN,EADM,CACH,QADG,EACO,KADP,EACc,SADd,CAAT,CAboB;AAe1B,UAAM,eAAe,wBACZ,QADY,CACH,OADG,EACM,KADN,EACa,SADb,CAAf,CAfoB;AAiB1B,UAAM,gBAAgB,wBACb,QADa,CACJ,QADI,EACM,KADN,EACa,SADb,CAAhB,CAjBoB;AAmB1B,YAAM,SAAN,GAAkB;AAChB,oBADgB;AAEhB,sBAFgB;AAGhB,kCAHgB;AAIhB,oCAJgB;OAAlB,CAnB0B;AAyB1B,cAAQ,IAAR,CAAa,cAAb,EACa,MAAM,KAAN,CAAY,KAAZ,EACA,MAAM,MAAN,EACA,MAAM,SAAN,CAHb,CAzB0B;KAA5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhDA,GAlBF;;AAmZA,iCAA+B,OAA/B,GAAyC,EAAzC,CA3aU;AA4aV,WAAS,8BAAT,GAA0C;AACxC,WAAO;AACL,gBAAU,GAAV;AACA,mBAAa,4CAAb;AACA,aAAO,IAAP;AACA,YAAM,IAAN;KAJF,CADwC;;AAQxC,aAAS,IAAT,CAAc,KAAd,EAAqB,OAArB,EAA8B;AAC5B,YAAM,IAAN,GAAa,QAAQ,CAAR,EAAW,YAAX,CAAwB,wBAAxB,CAAb,CAD4B;AAE5B,YAAM,wBAAN,CAA+B,oBAA/B,EAAqD,KAArD,EAF4B;AAG5B,cAAQ,GAAR,CAAY,qBAAZ,EAAmC,MAAM,IAAN,CAAnC,CAH4B;KAA9B;GARF;CA5aD,CAAD","file":"model.js","sourcesContent":["(function() {\n  angular.module('clickApp.directives')\n    .directive('clickGameModel', gameModelDirectiveFactory)\n    .directive('clickGameModelsList', gameModelsListDirectiveFactory);\n\n  gameModelDirectiveFactory.$inject = [\n    'appState',\n    'gameMap',\n    'gameFactions',\n    'model',\n    // 'gameModels',\n    'gameModelSelection',\n    // 'gameScenario',\n    // 'labelElement',\n    // 'clickGameModelArea',\n    // 'clickGameModelAura',\n    // 'clickGameModelBase',\n    // 'clickGameModelCharge',\n    // 'clickGameModelCounter',\n    // 'clickGameModelDamage',\n    // 'clickGameModelIcon',\n    // 'clickGameModelLoS',\n    // 'clickGameModelMelee',\n  ];\n  function gameModelDirectiveFactory(\n    appStateService,\n    gameMapService,\n    gameFactionsModel,\n    modelModel,\n    // gameModelsModel,\n    gameModelSelectionModel\n    // gameScenarioModel,\n    // labelElementModel,\n    // clickGameModelAreaModel,\n    // clickGameModelAuraModel,\n    // clickGameModelBaseModel,\n    // clickGameModelChargeModel,\n    // clickGameModelCounterModel,\n    // clickGameModelDamageModel,\n    // clickGameModelIconModel,\n    // clickGameModelLoSModel,\n    // clickGameModelMeleeModel\n  ) {\n    const clickGameModelDirective = {\n      restrict: 'A',\n      link: link\n    };\n    return clickGameModelDirective;\n\n    function link(scope, _parent_) {\n      const state = scope.state;\n      const model = scope.model;\n      const info = R.thread(state.factions)(\n        gameFactionsModel.getModelInfo$(model.state.info),\n        R.defaultTo({ base_radius: 5.905 })\n      );\n      console.log('gameModel', scope.model, info);\n\n      scope.onStateChangeEvent('Game.view.flipMap', onUpdate, scope);\n      scope.onStateChangeEvent('Game.models.change', onUpdate, scope);\n      scope.onStateChangeEvent('Game.model_selection.change', onUpdate, scope);\n      scope.onStateChangeEvent(`Game.model.change.${model.state.stamp}`,\n                               _onUpdate, scope);\n      updateModel(scope);\n\n      let _model;\n      let _selection;\n      let _is_flipped;\n      function onUpdate() {\n        const map = document.getElementById('map');\n        const is_flipped = gameMapService.isFlipped(map);\n        const state = appStateService.current();\n        const selection = R.path(['game','model_selection'], state);\n        const model = scope.model;\n        if(_model === model &&\n           _selection === selection &&\n           _is_flipped === is_flipped) {\n          return;\n        }\n        _model = model;\n        _selection = selection;\n        _is_flipped = is_flipped;\n\n        _onUpdate();\n      }\n      function _onUpdate() {\n        updateModel(scope);\n        scope.$digest();\n      }\n    }\n    function updateModel(scope) {\n      const map = document.getElementById('map');\n      const is_flipped = gameMapService.isFlipped(map);\n      const model = scope.model;\n\n      const state = appStateService.current();\n      scope.render = modelModel\n        .render(is_flipped, state.factions, model.state);\n\n      const selection = R.path(['game','model_selection'], state);\n      const stamp = model.state.stamp;\n      const local = gameModelSelectionModel\n              .in('local', stamp, selection);\n      const remote = gameModelSelectionModel\n              .in('remote', stamp, selection);\n      const single_local = gameModelSelectionModel\n              .inSingle('local', stamp, selection);\n      const single_remote = gameModelSelectionModel\n              .inSingle('remote', stamp, selection);\n      scope.selection = {\n        local,\n        remote,\n        single_local,\n        single_remote\n      };\n      console.warn('RENDER MODEL',\n                   model.state.stamp,\n                   scope.render,\n                   scope.selection);\n    }\n    // function buildModelElement(state, info, model, container, scope) {\n    //   const element = createModelElement(info, model, container);\n\n      // scope.$on('$destroy', gameModelOnDestroy(element));\n      // scope.onStateChangeEvent('Game.map.flipped',\n      //                          gameModelOnMapFlipped(info, scope, element),\n      //                          scope);\n      // const updateModel = gameModelOnUpdate(state, info, scope, element);\n      // scope.onStateChangeEvent(`Game.model.change.${model.state.stamp}`,\n      //                          updateModel, scope);\n      // updateModel();\n\n      // scope.onStateChangeEvent('Game.model.selection.local.updateSingle',\n      //                          onUpdateSingleModelSelection(scope, element),\n      //                          scope);\n\n      // scope.onStateChangeEvent('Game.template.selection.local.updateSingle',\n      //                          onUpdateSingleTemplateSelection(scope, element),\n      //                          scope);\n\n      // const onUpdateScenarioAura = withModel(scope, (model) => {\n      //   updateScenarioAura(state, info, model, scope, element);\n      // });\n      // scope.onStateChangeEvent('Game.scenario.refresh',\n      //                          onUpdateScenarioAura, scope);\n      // scope.onStateChangeEvent('Game.scenario.change',\n      //                          onUpdateScenarioAura, scope);\n    // }\n    // function createModelElement(info, model, parent) {\n    //   const map = document.getElementById('map');\n    //   const under_models_container = document.getElementById('game-under-models');\n    //   const over_models_container = document.getElementById('game-over-models');\n    //   const svgNS = map.namespaceURI;\n\n    //   const aura = clickGameModelAuraModel.create(svgNS, parent);\n    //   const melee = clickGameModelMeleeModel.create(svgNS, parent);\n    //   const base = clickGameModelBaseModel.create(svgNS, info, model, parent);\n    //   const damage = clickGameModelDamageModel.create(svgNS, info, parent);\n    //   const los = clickGameModelLoSModel.create(svgNS, info, parent);\n    //   const label = labelElementModel.create(svgNS, over_models_container);\n    //   const counter = clickGameModelCounterModel.create(svgNS, over_models_container, parent);\n    //   const unit = labelElementModel.create(svgNS, parent);\n    //   const icon = clickGameModelIconModel.create(svgNS, parent);\n    //   const area = clickGameModelAreaModel.create(svgNS, parent);\n    //   const charge = clickGameModelChargeModel.create(svgNS,\n    //                                                   under_models_container,\n    //                                                   over_models_container,\n    //                                                   parent);\n\n    //   return { container: parent,\n    //            aura: aura,\n    //            base: base,\n    //            damage: damage,\n    //            los: los,\n    //            label: label,\n    //            counter: counter,\n    //            unit: unit,\n    //            icon: icon,\n    //            area: area,\n    //            melee: melee,\n    //            charge: charge\n    //          };\n    // }\n    // function gameModelOnDestroy(element) {\n    //   return () => {\n    //     console.log('gameModelOnDestroy');\n\n    //     const under_models_container = document.getElementById('game-under-models');\n    //     const over_models_container = document.getElementById('game-over-models');\n    //     over_models_container.removeChild(element.label.label);\n    //     clickGameModelCounterModel.cleanup(under_models_container,\n    //                                        over_models_container,\n    //                                        element.counter);\n    //     clickGameModelChargeModel.cleanup(under_models_container,\n    //                                       over_models_container,\n    //                                       element.charge);\n    //   };\n    // }\n    // function withModel(scope, fn) {\n    //   return (...args) => {\n    //     R.threadP(scope.state.game.models)(\n    //       gameModelsModel.findStampP$(scope.model.state.stamp),\n    //       (model) => fn.apply(null, [model, ...args])\n    //     );\n    //   };\n    // }\n    // function gameModelOnMapFlipped(info, scope, element) {\n    //   return withModel(scope, (model) => {\n    //     const map = document.getElementById('map');\n\n    //     const label_center = computeLabelCenter(info, model);\n    //     labelElementModel.updateOnFlipMap(map,\n    //                                       label_center.flip,\n    //                                       element.label);\n    //     labelElementModel.updateOnFlipMap(map,\n    //                                       model.state,\n    //                                       element.counter[0]);\n    //     if(modelModel.isCharging(model) ||\n    //        modelModel.isPlacing(model)) {\n    //       labelElementModel.updateOnFlipMap(map,\n    //                                         model.state.cha.s,\n    //                                         element.charge[2]);\n    //     }\n    //   });\n    // }\n    // function onUpdateSingleModelSelection(scope, element) {\n    //   return withModel(scope, (model, _event_, sel_stamp, sel_model) => {\n    //     if(R.isNil(sel_model) ||\n    //        sel_stamp === model.state.stamp) {\n    //       element.container.classList.remove('overlap');\n    //       element.container.classList.remove('b2b');\n    //       return;\n    //     }\n    //     R.threadP(model)(\n    //       modelModel.distanceToP$(scope.state.factions, sel_model),\n    //       (dist) => {\n    //         if(dist < -0.1) {\n    //           element.container.classList.add('overlap');\n    //           element.container.classList.remove('b2b');\n    //           return;\n    //         }\n    //         else if(dist < 0.1) {\n    //           element.container.classList.remove('overlap');\n    //           element.container.classList.add('b2b');\n    //           return;\n    //         }\n    //         else {\n    //           element.container.classList.remove('overlap');\n    //           element.container.classList.remove('b2b');\n    //         }\n    //       }\n    //     );\n    //   });\n    // }\n    // function onUpdateSingleTemplateSelection(scope, element) {\n    //   return withModel(scope, (model, _event_, _sel_stamp_, sel_temp) => {\n    //     // console.log('onUpdateSingleAoTemplateSelection',\n    //     //             sel_stamp, model.state.stamp);\n    //     if(R.isNil(sel_temp) ||\n    //        'aoe' !== sel_temp.state.type) {\n    //       element.container.classList.remove('under-aoe');\n    //       return;\n    //     }\n    //     R.threadP(model)(\n    //       modelModel.distanceToAoEP$(scope.state.factions, sel_temp),\n    //       (dist) => {\n    //         if(dist <= 0) {\n    //           element.container.classList.add('under-aoe');\n    //         }\n    //         else {\n    //           element.container.classList.remove('under-aoe');\n    //         }\n    //       }\n    //     );\n    //   });\n    // }\n    // function gameModelOnUpdate(state, info,\n    //                            scope, element) {\n    //   return withModel(scope, (model) => {\n    //     const map = document.getElementById('map');\n    //     const map_flipped = gameMapService.isFlipped(map);\n    //     const zoom_factor = gameMapService.zoomFactor(map);\n\n    //     const is_wreck = modelModel.isWreckDisplayed(model);\n    //     (is_wreck\n    //      ? modelModel.getWreckImageP(state.factions, model)\n    //      : modelModel.getImageP(state.factions, model)\n    //     ).then((img) => {\n    //       const label_text = modelModel.fullLabel(model);\n    //       const label_center = computeLabelCenter(info, model);\n\n    //       updateModelPosition(img, model, element);\n    //       updateModelSelection(state.game.model_selection,\n    //                            model, element);\n    //       updateScenarioAura(state, info, model, scope, element);\n    //       clickGameModelAuraModel.update(info, model, img, element.aura);\n    //       clickGameModelBaseModel.update(info, model, img, element.base);\n    //       clickGameModelDamageModel.update(info, model, img, element.damage);\n    //       labelElementModel.update(map_flipped,\n    //                                zoom_factor,\n    //                                label_center.flip,\n    //                                label_center.text,\n    //                                label_text,\n    //                                element.label);\n    //       clickGameModelCounterModel.update(map_flipped, zoom_factor,\n    //                                         info, model, img, element.counter);\n    //       updateUnit(map_flipped, zoom_factor,\n    //                  img, info, model, element);\n    //       clickGameModelIconModel.update(info, model, img, element.icon);\n    //       clickGameModelAreaModel.update(state.factions, info, model, img, element.area);\n    //       clickGameModelMeleeModel.update(info, model, img, element.melee);\n    //       clickGameModelChargeModel.update(map_flipped, zoom_factor,\n    //                                        state, info, model, img, element.charge);\n    //     });\n    //   });\n    // }\n    // function updateModelPosition(img, model, element) {\n    //   element.container.setAttribute('transform', [\n    //     'translate(',\n    //     model.state.x-img.width/2,\n    //     ',',\n    //     model.state.y-img.height/2,\n    //     ') rotate(',\n    //     model.state.r,\n    //     ',',\n    //     img.width/2,\n    //     ',',\n    //     img.height/2,\n    //     ')'\n    //   ].join(''));\n    // }\n    // function updateModelSelection(selection, model, element) {\n    //   const container = element.container;\n    //   const stamp = model.state.stamp;\n    //   if(gameModelSelectionModel.in('local', stamp, selection)) {\n    //     container.classList.add('local-selection');\n    //   }\n    //   else {\n    //     container.classList.remove('local-selection');\n    //   }\n    //   if(gameModelSelectionModel.in('remote', stamp, selection)) {\n    //     container.classList.add('remote-selection');\n    //   }\n    //   else {\n    //     container.classList.remove('remote-selection');\n    //   }\n    //   if(gameModelSelectionModel.inSingle('local', stamp, selection)) {\n    //     container.classList.add('single-local');\n    //     container.classList.remove('single-remote');\n    //   }\n    //   else if(gameModelSelectionModel.inSingle('remote', stamp, selection)) {\n    //     container.classList.remove('single-local');\n    //     container.classList.add('single-remote');\n    //   }\n    //   else {\n    //     container.classList.remove('single-local');\n    //     container.classList.remove('single-remote');\n    //   }\n    // }\n    // function updateScenarioAura(state, info, model, scope, element) {\n    //   const circle = R.thread(model.state)(\n    //     R.pick(['x','y']),\n    //     R.assoc('radius', info.base_radius)\n    //   );\n\n    //   if(scope.app.stateIs('game.setup') &&\n    //      R.exists(state.game.scenario) &&\n    //      gameScenarioModel.isContesting(circle, state.game.scenario)) {\n    //     element.container.classList.add('contesting');\n    //   }\n    //   else {\n    //     element.container.classList.remove('contesting');\n    //   }\n    //   if(scope.app.stateIs('game.setup') &&\n    //      R.exists(state.game.scenario) &&\n    //      'wardude' === info.type &&\n    //      gameScenarioModel.isKillboxing(circle, state.game.scenario)) {\n    //     element.container.classList.add('killboxing');\n    //   }\n    //   else {\n    //     element.container.classList.remove('killboxing');\n    //   }\n    // }\n    // function updateUnit(map_flipped, zoom_factor, img, info, model, element) {\n    //   let unit = modelModel.unit(model);\n    //   unit = R.exists(unit) ? unit : '';\n\n    //   let unit_text = modelModel.isUnitDisplayed(model) ? unit+'' : '';\n    //   unit_text = R.length(unit_text) > 0 ? 'U'+unit_text : unit_text;\n\n    //   const unit_center = computeUnitCenter(img, info, model);\n    //   labelElementModel.update(map_flipped,\n    //                            zoom_factor,\n    //                            unit_center.flip,\n    //                            unit_center.text,\n    //                            unit_text,\n    //                            element.unit);\n    // }\n    // function computeLabelCenter(info, model) {\n    //   const label_text_center_y_down = model.state.y + info.base_radius + 6;\n    //   const label_text_center_y_up = model.state.y - info.base_radius - 2;\n    //   const orientation = ((model.state.r % 360) + 360) % 360;\n    //   const model_looking_down =  orientation > 90 && orientation < 270;\n    //   const label_text_center = { x: model.state.x,\n    //                               y: ( model_looking_down\n    //                                    ? label_text_center_y_down\n    //                                    : label_text_center_y_up\n    //                                  )\n    //                             };\n    //   const label_flip_center = { x: label_text_center.x,\n    //                               y: label_text_center.y - 2\n    //                             };\n    //   return { text: label_text_center,\n    //            flip: label_flip_center\n    //          };\n    // }\n    // function computeUnitCenter(img, info) {\n    //   const counter_flip_center = { x: img.width/2, y: img.height/2 };\n    //   const counter_text_center = { x: counter_flip_center.x - info.base_radius*0.7 - 5,\n    //                                 y: counter_flip_center.y - info.base_radius*0.7 - 5\n    //                               };\n    //   return { text: counter_text_center,\n    //            flip: counter_flip_center\n    //          };\n    // }\n  }\n\n  gameModelsListDirectiveFactory.$inject = [];\n  function gameModelsListDirectiveFactory() {\n    return {\n      restrict: 'A',\n      templateUrl: 'app/components/game/model/models_list.html',\n      scope: true,\n      link: link\n    };\n\n    function link(scope, element) {\n      scope.type = element[0].getAttribute('click-game-models-list');\n      scope.digestOnStateChangeEvent('Game.models.change', scope);\n      console.log('clickGameModelsList', scope.type);\n    }\n  }\n})();\n"]}