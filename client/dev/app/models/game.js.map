{"version":3,"sources":["game.es6"],"names":[],"mappings":"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","file":"game.js","sourcesContent":["(function() {\n  angular.module('clickApp.services')\n    .factory('game', gameModelFactory);\n\n  gameModelFactory.$inject = [\n    'jsonStringifier',\n    // 'commands',\n    // 'gameConnection',\n    // 'gameLayers',\n    // 'gameLos',\n    // 'gameModels',\n    // 'gameModelSelection',\n    // 'gameRuler',\n    // 'gameTemplates',\n    // 'gameTemplateSelection',\n    // 'gameTerrains',\n    // 'gameTerrainSelection',\n  ];\n  function gameModelFactory(jsonStringifierService) {\n                            // commandsModel,\n                            // gameConnectionModel,\n                            // gameLayersModel,\n                            // gameLosModel,\n                            // gameModelsModel,\n                            // gameModelSelectionModel,\n                            // gameRulerModel,\n                            // gameTemplatesModel,\n                            // gameTemplateSelectionModel,\n                            // gameTerrainsModel,\n                            // gameTerrainSelectionModel) {\n    const gameModel = {\n      create: gameCreate,\n      loadP: gameLoadP,\n      pickForJson: gamePickForJson,\n      toJson: gameToJson,\n      description: gameDescription,\n      // executeCommandP: gameExecuteCommandP,\n      // undoCommandP: gameUndoCommandP,\n      // undoLastCommandP: gameUndoLastCommandP,\n      // replayCommandP: gameReplayCommandP,\n      // replayCommandsBatchP: gameReplayCommandsBatchP,\n      // replayNextCommandP: gameReplayNextCommandP,\n      // sendChatP: gameSendChatP,\n      actionError: gameActionError\n    };\n\n    const GAME_PROTO = {\n      toJSON: function gameToJson() {\n        return gamePickForJson(this);\n      }\n    };\n    // const gameReplayAllP$ = R.curry(gameReplayAllP);\n\n    R.curryService(gameModel);\n    return gameModel;\n\n    function gameCreate(player1) {\n      var new_game = {\n        players: {\n          p1: { name: R.propOr('player1', 'name', player1) },\n          p2: { name: null }\n        }\n      };\n      return new_game;\n    }\n    function gameLoadP(state, data) {\n      return R.threadP(Object.create(GAME_PROTO))(\n        extendGameDefaultWithData\n        // gameConnectionModel.create,\n        // gameReplayAllP$(state)\n      );\n\n      function extendGameDefaultWithData(game) {\n        return R.deepExtend(game, defaultGameState(), data);\n      }\n    }\n    function defaultGameState() {\n      return {\n        players: {\n          p1: { name: null },\n          p2: { name: null }\n        },\n        board: {},\n        scenario: {},\n        chat: [],\n        commands: [],\n        commands_log: [],\n        undo: [],\n        undo_log: [],\n        dice: [],\n        // ruler: gameRulerModel.create(),\n        // los: gameLosModel.create(),\n        // models: gameModelsModel.create(),\n        // model_selection: gameModelSelectionModel.create(),\n        // templates: gameTemplatesModel.create(),\n        // template_selection: gameTemplateSelectionModel.create(),\n        // terrains: gameTerrainsModel.create(),\n        // terrain_selection: gameTerrainSelectionModel.create(),\n        // layers: gameLayersModel.create()\n      };\n    }\n    function gamePickForJson(game) {\n      return R.pick([\n        'players', 'commands', 'undo', 'chat',\n        'local_stamp', 'private_stamp', 'public_stamp'\n      ], game);\n    }\n    function gameToJson(game) {\n      return R.thread(game)(\n        gamePickForJson,\n        jsonStringifierService.stringify\n      );\n    }\n    function gamePlayerName(p, game) {\n      return R.pathOr('John Doe', ['players',p,'name'], game);\n    }\n    function gameDescription(game) {\n      return [ s.capitalize(gamePlayerName('p1', game)),\n               'vs',\n               s.capitalize(gamePlayerName('p2', game))\n             ].join(' ');\n    }\n    // function gameExecuteCommandP(cmd, args, state, game) {\n    //   return R.threadP(commandsModel.executeP(cmd, args, state, game))(\n    //     stampCommand,\n    //     R.ifElse(\n    //       ([_c_, game]) => gameConnectionModel.active(game),\n    //       sendReplayCommandP,\n    //       logLocalCommand\n    //     ),\n    //     ([ command, game ]) => R.when(\n    //       () => (command.type === 'rollDice' ||\n    //              command.type === 'rollDeviation'),\n    //       R.over(R.lensProp('dice'), R.append(command)),\n    //       game\n    //     ),\n    //     R.tap(() => { state.queueChangeEventP('Game.command.execute'); })\n    //   );\n\n    //   function stampCommand([command, game]) {\n    //     return [ R.thread(command)(\n    //       R.assoc('user', R.pathOr('Unknown', ['user','state','name'], state)),\n    //       R.assoc('stamp', R.guid())\n    //     ), game ];\n    //   }\n    //   function sendReplayCommandP([command, game]) {\n    //     return R.threadP(game)(\n    //       gameConnectionModel.sendReplayCommandP$(command),\n    //       (game) => [ command, game ]\n    //     );\n    //   }\n    //   function logLocalCommand([command, game]) {\n    //     return [ command, R.unless(\n    //       () => command.do_not_log,\n    //       R.over(R.lensProp('commands'), R.append(command)),\n    //       game\n    //     ) ];\n    //   }\n    // }\n    // function gameUndoCommandP(command, state, game) {\n    //   return R.threadP(game)(\n    //     R.ifElse(\n    //       isInUndoLog,\n    //       removeFromUndoLog,\n    //       commandsModel.undoP$(command, state)\n    //     ),\n    //     updateLogs,\n    //     R.tap(() => { state.queueChangeEventP('Game.command.undo'); })\n    //   );\n\n    //   function isInUndoLog(game) {\n    //     return R.thread(game)(\n    //       R.propOr([], 'undo_log'),\n    //       R.find(R.propEq('stamp', command.stamp))\n    //     );\n    //   }\n    //   function removeFromUndoLog(game) {\n    //     return R.over(R.lensProp('undo_log'),\n    //                   R.compose(R.reject(R.propEq('stamp', command.stamp)),\n    //                             R.defaultTo([])),\n    //                   game);\n    //   }\n    //   function updateLogs(game) {\n    //     return R.thread(game)(\n    //       R.over(R.lensProp('commands'), R.reject(R.propEq('stamp', command.stamp))),\n    //       R.over(R.lensProp('undo'), R.append(command))\n    //     );\n    //   }\n    // }\n    // function gameUndoLastCommandP(state, game) {\n    //   return R.threadP(game)(\n    //     getLastCommand,\n    //     undoCommand,\n    //     updateLogs,\n    //     R.tap(() => { state.queueChangeEventP('Game.command.undo'); })\n    //   );\n\n    //   function getLastCommand(game) {\n    //     return R.threadP(game)(\n    //       R.propOr([],'commands'),\n    //       R.last,\n    //       R.rejectIfP(R.isNil, 'Command history empty')\n    //     );\n    //   }\n    //   function undoCommand(command) {\n    //     return R.threadP(game)(\n    //       commandsModel.undoP$(command, state),\n    //       (game) => [command, game]\n    //     );\n    //   }\n    //   function updateLogs([command, game]) {\n    //     return R.threadP(game)(\n    //       R.over(R.lensProp('commands'), R.init),\n    //       R.ifElse(\n    //         gameConnectionModel.active,\n    //         gameConnectionModel.sendUndoCommandP$(command),\n    //         R.over(R.lensProp('undo'), R.append(command))\n    //       )\n    //     );\n    //   }\n    // }\n    // function gameReplayCommandP(command, state, game) {\n    //   return R.threadP(game)(\n    //     R.ifElse(\n    //       isInCommandsLog,\n    //       removeFromCommandsLog,\n    //       commandsModel.replayP$(command, state)\n    //     ),\n    //     updateLogs,\n    //     R.tap(() => { state.queueChangeEventP('Game.command.replay'); })\n    //   );\n\n    //   function isInCommandsLog(game) {\n    //     return R.thread(game)(\n    //       R.propOr([], 'commands_log'),\n    //       R.find(R.propEq('stamp', command.stamp))\n    //     );\n    //   }\n    //   function removeFromCommandsLog(game) {\n    //     return R.over(R.lensProp('commands_log'),\n    //                   R.reject(R.propEq('stamp', command.stamp)),\n    //                   game);\n    //   }\n    //   function updateLogs(game) {\n    //     return R.thread(game)(\n    //       R.over(R.lensProp('undo'), R.reject(R.propEq('stamp', command.stamp))),\n    //       R.unless(\n    //         () => command.do_not_log,\n    //         R.over(R.lensProp('commands'), R.append(command))\n    //       )\n    //     );\n    //   }\n    // }\n    // function gameReplayCommandsBatchP(cmds, state, game) {\n    //   return R.threadP(game)(\n    //     commandsModel.replayBatchP$(cmds, state),\n    //     R.over(R.lensProp('commands'), R.flip(R.concat)(cmds))\n    //   );\n    // }\n    // function gameReplayNextCommandP(state, game) {\n    //   return R.threadP(game)(\n    //     getNextUndo,\n    //     replayCommand,\n    //     updateLogs,\n    //     R.tap(() => { state.queueChangeEventP('Game.command.replay'); })\n    //   );\n\n    //   function getNextUndo(game) {\n    //     return R.threadP(game)(\n    //       R.propOr([], 'undo'),\n    //       R.last,\n    //       R.rejectIfP(R.isNil, 'Undo history empty')\n    //     );\n    //   }\n    //   function replayCommand(command) {\n    //     return R.threadP(game)(\n    //       commandsModel.replayP$(command, state),\n    //       (game) => [command, game]\n    //     );\n    //   }\n    //   function updateLogs([command, game]) {\n    //     return R.threadP(game)(\n    //       R.over(R.lensProp('undo'), R.init),\n    //       R.ifElse(\n    //         gameConnectionModel.active,\n    //         gameConnectionModel.sendReplayCommandP$(command),\n    //         R.over(R.lensProp('commands'), R.append(command))\n    //       )\n    //     );\n    //   }\n    // }\n    // function gameSendChatP(from, msg, game) {\n    //   return gameConnectionModel\n    //     .sendEventP({\n    //       type: 'chat',\n    //       chat: {\n    //         from: from,\n    //         msg: msg\n    //       }\n    //     }, game);\n    // }\n    // function gameReplayBatchsP(batchs, state, game) {\n    //   if(R.isEmpty(batchs)) {\n    //     return self.Promise.resolve(game);\n    //   }\n\n    //   console.log('Game: ReplayBatchs:', batchs);\n    //   return R.threadP(game)(\n    //     commandsModel.replayBatchP$(batchs[0], state),\n    //     recurP\n    //   );\n\n    //   function recurP(game) {\n    //     return new self.Promise((resolve) => {\n    //       self.requestAnimationFrame(() => {\n    //         resolve(gameReplayBatchsP(R.tail(batchs), state, game));\n    //       });\n    //     });\n    //   }\n    // }\n    // function gameReplayAllP(state, game) {\n    //   return new self.Promise((resolve) => {\n    //     if(R.isEmpty(game.commands)) {\n    //       resolve(game);\n    //     }\n\n    //     var batchs = R.splitEvery(game.commands.length, game.commands);\n    //     self.requestAnimationFrame(() => {\n    //       resolve(gameReplayBatchsP(batchs, state, game));\n    //     });\n    //   });\n    // }\n    function gameActionError(state, error) {\n      state.queueChangeEventP('Game.action.error', error);\n      return null;\n    }\n  }\n})();\n"]}