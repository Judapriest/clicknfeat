{"version":3,"sources":["game.es6"],"names":[],"mappings":";;AAAA,CAAC,YAAW;AACV,UAAQ,MAAR,CAAe,mBAAf,EACG,OADH,CACW,MADX,EACmB,gBADnB,EADU;;AAIV,mBAAiB,OAAjB,GAA2B,CACzB,iBADyB,CAA3B,CAJU;;;;;;;;;;;;;AAkBV,WAAS,gBAAT,CAA0B;;;;;;;;;;;;AAA1B,IAY6B;AAC3B,QAAM,YAAY;AAChB,cAAQ,UAAR;;;AAGA,cAAQ,UAAR;;AAEA,mBAAa,eAAb;KANI;;AADqB;;;;;;;AAiB3B,MAAE,YAAF,CAAe,SAAf,EAjB2B;AAkB3B,WAAO,SAAP,CAlB2B;;AAoB3B,aAAS,UAAT,CAAoB,OAApB,EAA6B;AAC3B,UAAI,WAAW;AACb,iBAAS;AACP,cAAI,EAAE,MAAM,EAAE,MAAF,CAAS,SAAT,EAAoB,MAApB,EAA4B,OAA5B,CAAN,EAAN;AACA,cAAI,EAAE,MAAM,IAAN,EAAN;SAFF;OADE,CADuB;AAO3B,aAAO,QAAP,CAP2B;KAA7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApB2B,aAiElB,eAAT,CAAyB,IAAzB,EAA+B;AAC7B,aAAO,EAAE,IAAF,CAAO,CACZ,SADY,EACD,UADC,EACW,MADX,EACmB,MADnB,EAEZ,aAFY,EAEG,eAFH,EAEoB,cAFpB,CAAP,EAGJ,IAHI,CAAP,CAD6B;KAA/B;AAMA,aAAS,UAAT,CAAoB,IAApB,EAA0B;AACxB,aAAO,EAAE,MAAF,CAAS,IAAT,EACL,eADK,EAEL,uBAAuB,SAAvB,CAFF,CADwB;KAA1B;AAMA,aAAS,cAAT,CAAwB,CAAxB,EAA2B,IAA3B,EAAiC;AAC/B,aAAO,EAAE,MAAF,CAAS,UAAT,EAAqB,CAAC,SAAD,EAAW,CAAX,EAAa,MAAb,CAArB,EAA2C,IAA3C,CAAP,CAD+B;KAAjC;AAGA,aAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC7B,aAAO,CAAE,EAAE,UAAF,CAAa,eAAe,IAAf,EAAqB,IAArB,CAAb,CAAF,EACE,IADF,EAEE,EAAE,UAAF,CAAa,eAAe,IAAf,EAAqB,IAArB,CAAb,CAFF,EAGE,IAHF,CAGO,GAHP,CAAP,CAD6B;KAA/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhF2B,GAZ7B;CAlBD,CAAD","file":"game.js","sourcesContent":["(function() {\n  angular.module('clickApp.services')\n    .factory('game', gameModelFactory);\n\n  gameModelFactory.$inject = [\n    'jsonStringifier',\n    // 'commands',\n    // 'gameConnection',\n    // 'gameLayers',\n    // 'gameLos',\n    // 'gameModels',\n    // 'gameModelSelection',\n    // 'gameRuler',\n    // 'gameTemplates',\n    // 'gameTemplateSelection',\n    // 'gameTerrains',\n    // 'gameTerrainSelection',\n  ];\n  function gameModelFactory(jsonStringifierService\n                              // commandsService,\n                              // gameConnectionService,\n                              // gameLayersService,\n                              // gameLosService,\n                              // gameModelsService,\n                              // gameModelSelectionService,\n                              // gameRulerService,\n                              // gameTemplatesService,\n                              // gameTemplateSelectionService,\n                              // gameTerrainsService,\n                              // gameTerrainSelectionService\n                             ) {\n    const gameModel = {\n      create: gameCreate,\n      // load: gameLoad,\n      // pickForJson: gamePickForJson,\n      toJson: gameToJson,\n      // playerName: gamePlayerName,\n      description: gameDescription,\n      // executeCommand: gameExecuteCommand,\n      // undoCommand: gameUndoCommand,\n      // undoLastCommand: gameUndoLastCommand,\n      // replayCommand: gameReplayCommand,\n      // replayCommandsBatch: gameReplayCommandsBatch,\n      // replayNextCommand: gameReplayNextCommand,\n      // sendChat: gameSendChat\n    };\n    // const gameReplayAll$ = R.curry(gameReplayAll);\n    R.curryService(gameModel);\n    return gameModel;\n\n    function gameCreate(player1) {\n      var new_game = {\n        players: {\n          p1: { name: R.propOr('player1', 'name', player1) },\n          p2: { name: null }\n        }\n      };\n      return new_game;\n    }\n    // function gameLoad(state, data) {\n    //   return R.pipe(\n    //     () => {\n    //       return Object.create({\n    //         toJSON: function() { return gameModel.pickForJson(this); }\n    //       });\n    //     },\n    //     (game) => {\n    //       return R.deepExtend(game, {\n    //         players: {\n    //           p1: { name: null },\n    //           p2: { name: null }\n    //         },\n    //         board: {},\n    //         scenario: {},\n    //         chat: [],\n    //         commands: [],\n    //         commands_log: [],\n    //         undo: [],\n    //         undo_log: [],\n    //         dice: [],\n    //         ruler: gameRulerService.create(),\n    //         los: gameLosService.create(),\n    //         models: gameModelsService.create(),\n    //         model_selection: gameModelSelectionService.create(),\n    //         templates: gameTemplatesService.create(),\n    //         template_selection: gameTemplateSelectionService.create(),\n    //         terrains: gameTerrainsService.create(),\n    //         terrain_selection: gameTerrainSelectionService.create(),\n    //         layers: gameLayersService.create()\n    //       }, data);\n    //     },\n    //     gameConnectionService.create,\n    //     gameReplayAll$(state)\n    //   )();\n    // }\n    function gamePickForJson(game) {\n      return R.pick([\n        'players', 'commands', 'undo', 'chat',\n        'local_stamp', 'private_stamp', 'public_stamp'\n      ], game);\n    }\n    function gameToJson(game) {\n      return R.thread(game)(\n        gamePickForJson,\n        jsonStringifierService.stringify\n      );\n    }\n    function gamePlayerName(p, game) {\n      return R.pathOr('John Doe', ['players',p,'name'], game);\n    }\n    function gameDescription(game) {\n      return [ s.capitalize(gamePlayerName('p1', game)),\n               'vs',\n               s.capitalize(gamePlayerName('p2', game))\n             ].join(' ');\n    }\n    // function gameExecuteCommand(cmd, args, state, game) {\n    //   return R.pipeP(\n    //     () => {\n    //       return commandsService.execute\n    //         .apply(null, [cmd, args, state, game]);\n    //     },\n    //     ([command, game]) => {\n    //       return [ R.pipe(\n    //         R.assoc('user', R.pathOr('Unknown', ['user','state','name'], state)),\n    //         R.assoc('stamp', R.guid())\n    //       )(command),\n    //                game\n    //              ];\n    //     },\n    //     ([command, game]) => {\n    //       if(gameConnectionService.active(game)) {\n    //         return gameConnectionService\n    //           .sendReplayCommand(command, game);\n    //       }\n    //       if(!command.do_not_log) {\n    //         game = R.over(R.lensProp('commands'),\n    //                       R.append(command),\n    //                       game);\n    //       }\n    //       if(command.type === 'rollDice' ||\n    //          command.type === 'rollDeviation') {\n    //         game = R.over(R.lensProp('dice'),\n    //                       R.append(command),\n    //                       game);\n    //       }\n    //       return game;\n    //     },\n    //     (game) => {\n    //       state.changeEvent('Game.command.execute');\n    //       return game;\n    //     }\n    //   )();\n    // }\n    // function gameUndoCommand(command, state, game) {\n    //   return R.pipePromise(\n    //     R.propOr([], 'undo_log'),\n    //     R.find(R.propEq('stamp', command.stamp)),\n    //     (log) => {\n    //       if(R.exists(log)) {\n    //         console.log('Game : undoCmd log', command);\n    //         let log = R.propOr([], 'undo_log', game);\n    //         return R.assoc('undo_log',\n    //                        R.reject(R.propEq('stamp', command.stamp), log),\n    //                        game);\n    //       }\n    //       return commandsService\n    //         .undo(command, state, game);\n    //     },\n    //     (game) => {\n    //       let commands = R.propOr([], 'commands', game);\n    //       let undo = R.propOr([], 'undo', game);\n    //       return R.pipe(\n    //         R.assoc('commands', R.reject(R.propEq('stamp', command.stamp), commands)),\n    //         R.assoc('undo', R.append(command, undo))\n    //       )(game);\n    //     },\n    //     (game) => {\n    //       state.changeEvent('Game.command.undo');\n    //       return game;\n    //     }\n    //   )(game);\n    // }\n    // function gameUndoLastCommand(state, game) {\n    //   return R.pipePromise(\n    //     R.propOr([],'commands'),\n    //     R.last,\n    //     R.rejectIf(R.isNil, 'Command history empty'),\n    //     (command) => {\n    //       return R.pipeP(\n    //         commandsService.undo$(command, state),\n    //         (game) => { return [command, game]; }\n    //       )(game);\n    //     },\n    //     ([command, game]) => {\n    //       return R.pipePromise(\n    //         R.assoc('commands', R.init(game.commands)),\n    //         (game) => {\n    //           if(gameConnectionService.active(game)) {\n    //             return gameConnectionService\n    //               .sendUndoCommand(command, game);\n    //           }\n    //           return R.over(R.lensProp('undo'),\n    //                         R.append(command),\n    //                         game);\n    //         }\n    //       )(game);\n    //     },\n    //     (game) => {\n    //       state.changeEvent('Game.command.undo');\n    //       return game;\n    //     }\n    //   )(game);\n    // }\n    // function gameReplayCommand(command, state, game) {\n    //   return R.pipePromise(\n    //     R.propOr([], 'commands_log'),\n    //     R.find(R.propEq('stamp', command.stamp)),\n    //     (log) => {\n    //       if(R.exists(log)) {\n    //         console.log('Game: replayCmd log', command);\n    //         return R.over(R.lensProp('commands_log'),\n    //                       R.reject(R.propEq('stamp', command.stamp)),\n    //                       game);\n    //       }\n    //       return commandsService\n    //         .replay(command, state, game);\n    //     },\n    //     (game) => {\n    //       return R.pipe(\n    //         R.over(R.lensProp('undo'),\n    //                R.reject(R.propEq('stamp', command.stamp))),\n    //         (game) => {\n    //           if(command.do_not_log) return game;\n\n    //           return R.over(R.lensProp('commands'),\n    //                         R.append(command),\n    //                         game);\n    //         }\n    //       )(game);\n    //     },\n    //     (game) => {\n    //       state.changeEvent('Game.command.replay');\n    //       return game;\n    //     }\n    //   )(game);\n    // }\n    // function gameReplayCommandsBatch(cmds, state, game) {\n    //   return R.pipeP(\n    //     commandsService.replayBatch$(cmds, state),\n    //     R.over(R.lensProp('commands'),\n    //            R.flip(R.concat)(cmds))\n    //   )(game);\n    // }\n    // function gameReplayNextCommand(state, game) {\n    //   return R.pipePromise(\n    //     R.propOr([], 'undo'),\n    //     R.last,\n    //     (command) => {\n    //       if(R.isNil(command)) {\n    //         return self.Promise\n    //           .reject('Undo history empty');\n    //       }\n    //       return R.pipeP(\n    //         commandsService.replay$(command, state),\n    //         (game) => { return [command, game]; }\n    //       )(game);\n    //     },\n    //     ([command, game]) => {\n    //       return R.pipePromise(\n    //         R.assoc('undo', R.init(game.undo)),\n    //         (game) => {\n    //           if(gameConnectionService.active(game)) {\n    //             return gameConnectionService\n    //               .sendReplayCommand(command, game);\n    //           }\n    //           let commands = R.propOr([], 'commands', game);\n    //           return R.assoc('commands', R.append(command, commands), game);\n    //         }\n    //       )(game);\n    //     },\n    //     (game) => {\n    //       state.changeEvent('Game.command.replay');\n    //       return game;\n    //     }\n    //   )(game);\n    // }\n    // function gameSendChat(from, msg, game) {\n    //   return gameConnectionService\n    //     .sendEvent({\n    //       type: 'chat',\n    //       chat: {\n    //         from: from,\n    //         msg: msg\n    //       }\n    //     }, game);\n    // }\n    // function gameReplayBatchs(batchs, state, game) {\n    //   if(R.isEmpty(batchs)) return game;\n\n    //   console.log('Game: ReplayBatchs:', batchs);\n    //   return R.pipeP(\n    //     commandsService.replayBatch$(batchs[0], state),\n    //     (game) => {\n    //       return new self.Promise((resolve) => {\n    //         self.requestAnimationFrame(() => {\n    //           resolve(gameReplayBatchs(R.tail(batchs), state, game));\n    //       });\n    //       });\n    //     }\n    //   )(game);\n    // }\n    // function gameReplayAll(state, game) {\n    //   return new self.Promise((resolve) => {\n    //     if(R.isEmpty(game.commands)) {\n    //       resolve(game);\n    //     }\n\n    //     var batchs = R.splitEvery(game.commands.length, game.commands);\n    //     self.requestAnimationFrame(() => {\n    //       resolve(gameReplayBatchs(batchs, state, game));\n    //     });\n    //   });\n    // }\n  }\n})();\n"]}