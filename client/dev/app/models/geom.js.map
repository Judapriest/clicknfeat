{"version":3,"sources":["geom.es6"],"names":[],"mappings":"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","file":"geom.js","sourcesContent":["(function() {\n  angular.module('clickApp.services')\n    .factory('point', pointModelFactory);\n    // .factory('line', lineModelFactory)\n    // .factory('circle', circleModelFactory);\n\n  pointModelFactory.$inject = [];\n  function pointModelFactory() {\n    const pointModel = {\n      moveFront: pointMoveFront,\n      moveBack: pointMoveBack,\n      rotateLeft: pointRotateLeft,\n      rotateLeftAround: pointRotateLeftAround,\n      rotateRight: pointRotateRight,\n      rotateRightAround: pointRotateRightAround,\n      rotateAroundTo: pointRotateAroundTo,\n      shiftLeft: pointShiftLeft,\n      shiftRight: pointShiftRight,\n      shiftUp: pointShiftUp,\n      shiftDown: pointShiftDown,\n      distanceTo: pointDistanceTo,\n      directionTo: pointDirectionTo,\n      translateInDirection: pointTranslateInDirection,\n      translateInVector: pointTranslateInVector,\n      addToWithFlip: pointAddToWithFlip,\n      differenceFrom: pointDifferenceFrom,\n      vectorProduct: pointVectorProduct,\n      scalarProduct: pointScalarProduct\n    };\n\n    R.curryService(pointModel);\n    return pointModel;\n\n    function pointMoveFront(dist, point) {\n      const rad = point.r * Math.PI / 180;\n      return R.pipe(\n        R.assoc('x', point.x + dist * Math.sin(rad)),\n        R.assoc('y', point.y - dist * Math.cos(rad))\n      )(point);\n    }\n    function pointMoveBack(dist, point) {\n      const rad = point.r * Math.PI / 180;\n      return R.pipe(\n        R.assoc('x', point.x - dist * Math.sin(rad)),\n        R.assoc('y', point.y + dist * Math.cos(rad))\n      )(point);\n    }\n    function pointRotateLeft(angle, point) {\n      return R.assoc('r', point.r - angle, point);\n    }\n    function pointRotateLeftAround(angle, center, point) {\n      const direction = pointModel.directionTo(point, center);\n      const distance = pointModel.distanceTo(point, center);\n      const new_direction = direction - angle;\n      return R.pipe(\n        R.assoc('x', center.x + distance * Math.sin(new_direction * Math.PI / 180)),\n        R.assoc('y', center.y - distance * Math.cos(new_direction * Math.PI / 180))\n      )(point);\n    }\n    function pointRotateRight(angle, point) {\n      return R.assoc('r', point.r + angle, point);\n    }\n    function pointRotateRightAround(angle, center, point) {\n      const direction = pointModel.directionTo(point, center);\n      const distance = pointModel.distanceTo(point, center);\n      const new_direction = direction + angle;\n      return R.pipe(\n        R.assoc('x', center.x + distance * Math.sin(new_direction * Math.PI / 180)),\n        R.assoc('y', center.y - distance * Math.cos(new_direction * Math.PI / 180))\n      )(point);\n    }\n    function pointRotateAroundTo(direction, center, point) {\n      const distance = pointModel.distanceTo(point, center);\n      return R.pipe(\n        R.assoc('x', center.x + distance * Math.sin(direction * Math.PI / 180)),\n        R.assoc('y', center.y - distance * Math.cos(direction * Math.PI / 180))\n      )(point);\n    }\n    function pointShiftLeft(dist, point) {\n      return R.assoc('x', point.x - dist, point);\n    }\n    function pointShiftRight(dist, point) {\n      return R.assoc('x', point.x + dist, point);\n    }\n    function pointShiftUp(dist, point) {\n      return R.assoc('y', point.y - dist, point);\n    }\n    function pointShiftDown(dist, point) {\n      return R.assoc('y', point.y + dist, point);\n    }\n    function pointDistanceTo(other, point) {\n      return Math.sqrt( Math.pow(other.x - point.x, 2) +\n                        Math.pow(other.y - point.y, 2)\n                      );\n    }\n    function pointDirectionTo(other, point) {\n      return 180 * Math.atan2(\n        other.x - point.x,\n        point.y - other.y\n      ) / Math.PI;\n    }\n    function pointTranslateInDirection(distance, direction, point) {\n      direction = direction * Math.PI / 180;\n      return R.pipe(\n        R.assoc('x', point.x + distance * Math.sin(direction)),\n        R.assoc('y', point.y - distance * Math.cos(direction))\n      )(point);\n    }\n    function pointTranslateInVector(distance, vector, point) {\n      return R.pipe(\n        R.assoc('x', point.x + distance * vector.x),\n        R.assoc('y', point.y + distance * vector.y)\n      )(point);\n    }\n    function pointAddToWithFlip(flip, other, point) {\n      const coeff = flip ? -1 : 1;\n      const phase = flip ? 180 : 0;\n      return R.pipe(\n        R.assoc('x', other.x + coeff * point.x),\n        R.assoc('y', other.y + coeff * point.y),\n        R.assoc('r', other.r + point.r + phase)\n      )(point);\n    }\n    function pointDifferenceFrom(other, point) {\n      return R.pipe(\n        R.assoc('x', point.x - other.x),\n        R.assoc('y', point.y - other.y),\n        R.assoc('r', point.r - other.r)\n      )(point);\n    }\n    function pointVectorProduct(other, point) {\n      return other.y * point.x - other.x * point.y;\n    }\n    function pointScalarProduct(other, point) {\n      return other.x * point.x + other.y * point.y;\n    }\n\n  }\n\n  // lineModelFactory.$inject = [\n  //   'point'\n  // ];\n  // function lineModelFactory(pointModel) {\n  //   const lineModel = {\n  //     length: lineLength,\n  //     vector: lineVector\n  //   };\n  //   R.curryService(lineModel);\n  //   return lineModel;\n\n  //   function lineLength(line) {\n  //     return pointModel.distanceTo(line.end, line.start);\n  //   }\n  //   function lineVector(line) {\n  //     const length = lineModel.length(line);\n  //     return {\n  //       x: (line.end.x - line.start.x) / length,\n  //       y: (line.end.y - line.start.y) / length\n  //     };\n  //   }\n  // }\n\n  // circleModelFactory.$inject = [\n  //   'point',\n  //   'line',\n  // ];\n  // function circleModelFactory(pointModel,\n  //                             lineModel) {\n  //   const circleModel = {\n  //     positionToLine: circlePositionToLine,\n  //     isLeftOfLine: circleIsLeftOfLine,\n  //     isRightOfLine: circleIsRightOfLine,\n  //     isInEnvelope: circleIsInEnvelope,\n  //     isInBox: circleIsInBox,\n  //     intersectLine: circleIntersectLine,\n  //     pointOnEdgeInDirection: circlePointOnEdgeInDirection,\n  //     pointOnEdgeTangentTo: circlePointOnEdgeTangentTo,\n  //     envelopeDirectionsTo: circleEnvelopeDirectionsTo,\n  //     envelopeTo: circleEnvelopeTo,\n  //     outsideEnvelopeTo: circleOutsideEnvelopeTo\n  //   };\n\n  //   R.curryService(circleModel);\n  //   return circleModel;\n\n  //   function circlePositionToLine (line, circle) {\n  //     const delta = pointModel.differenceFrom(line.start, circle);\n  //     const line_length = lineModel.length(line);\n  //     const line_vector = lineModel.vector(line);\n  //     const vect_prod = pointModel.vectorProduct(line_vector, delta);\n  //     const scal_prod = pointModel.scalarProduct(line_vector, delta);\n\n  //     return [vect_prod, scal_prod, line_length];\n  //   }\n  //   function circleIsLeftOfLine(line, circle) {\n  //     const [ vect_prod, scal_prod, line_length ] =\n  //           circleModel.positionToLine(line, circle);\n\n  //     return ( vect_prod + circle.radius >= 0 &&\n  //              scal_prod + circle.radius >= 0 &&\n  //              scal_prod - circle.radius <= line_length\n  //            );\n  //   }\n  //   function circleIsRightOfLine(line, circle) {\n  //     const [ vect_prod, scal_prod, line_length ] =\n  //           circleModel.positionToLine(line, circle);\n\n  //     return ( vect_prod - circle.radius <= 0 &&\n  //              scal_prod + circle.radius >= 0 &&\n  //              scal_prod - circle.radius <= line_length\n  //            );\n  //   }\n  //   function circleIsInEnvelope(envelope, circle) {\n  //     return ( circleModel.isRightOfLine(envelope.left, circle) &&\n  //              circleModel.isLeftOfLine(envelope.right, circle)\n  //            );\n  //   }\n  //   function circleIsInBox(box, circle) {\n  //     const dx;\n  //     const dy;\n  //     if(circle.x >= box.low.x &&\n  //        circle.x <= box.high.x &&\n  //        circle.y >= box.low.y &&\n  //        circle.y <= box.high.x) return true;\n  //     if(circle.x >= box.low.x - circle.radius &&\n  //        circle.x <  box.low.x) {\n  //       dx = box.low.x - circle.x;\n  //       dy = Math.sqrt(circle.radius * circle.radius - dx * dx);\n  //       return ( circle.y + dy >= box.low.y &&\n  //                circle.y - dy <= box.high.y\n  //              );\n  //     }\n  //     if(circle.x <= box.high.x + circle.radius &&\n  //        circle.x >  box.high.x) {\n  //       dx = box.high.x - circle.x;\n  //       dy = Math.sqrt(circle.radius * circle.radius - dx * dx);\n  //       return ( circle.y + dy >= box.low.y &&\n  //                circle.y - dy <= box.high.y\n  //              );\n  //     }\n  //     if(circle.y >= box.low.y - circle.radius &&\n  //        circle.y <  box.low.y) {\n  //       dy = box.low.y - circle.y;\n  //       dx = Math.sqrt(circle.radius * circle.radius - dy * dy);\n  //       return ( circle.x + dx >= box.low.x &&\n  //                circle.x - dx <= box.high.x\n  //              );\n  //     }\n  //     if(circle.y <= box.high.y + circle.radius &&\n  //        circle.y >  box.high.y) {\n  //       dy = box.high.y - circle.y;\n  //       dx = Math.sqrt(circle.radius * circle.radius - dy * dy);\n  //       return ( circle.x + dx >= box.low.x &&\n  //                circle.x - dx <= box.high.x\n  //              );\n  //     }\n  //     return false;\n  //   }\n  //   function circleIntersectLine(line, circle) {\n  //     const [ vect_prod, scal_prod, line_length ] =\n  //           circleModel.positionToLine(line, circle);\n\n  //     return ( Math.abs(vect_prod) < circle.radius &&\n  //              scal_prod + circle.radius >= 0 &&\n  //              scal_prod - circle.radius <= line_length\n  //            );\n  //   }\n  //   function circlePointOnEdgeInDirection(direction, circle) {\n  //     return {\n  //       x: circle.x + Math.sin(Math.PI * direction / 180) * circle.radius,\n  //       y: circle.y - Math.cos(Math.PI * direction / 180) * circle.radius\n  //     };\n  //   }\n  //   function circlePointOnEdgeTangentTo(point, left, circle) {\n  //     const distance = pointModel.distanceTo(circle, point);\n  //     const direction = pointModel.directionTo(circle, point);\n  //     const delta_direction = 180 * Math.acos(circle.radius / distance) / Math.PI;\n  //     const tangent_direction = ( !left ?\n  //                               direction + 180 - delta_direction :\n  //                               direction - 180 + delta_direction\n  //                             );\n\n  //     return circleModel.pointOnEdgeInDirection(tangent_direction, circle);\n  //   }\n  //   function circleEnvelopeDirectionsTo(target, origin) {\n  //     const direction = pointModel.directionTo(target, origin);\n  //     const distance = pointModel.distanceTo(target, origin);\n  //     const delta_radius = Math.abs(origin.radius - target.radius);\n  //     const delta_direction = 180 * ( Math.asin(delta_radius/distance) *\n  //                                   (origin.radius >= target.radius ? 1 : -1)\n  //                                 ) / Math.PI;\n  //     return {\n  //       right: direction - delta_direction + 90,\n  //       left: direction + delta_direction - 90\n  //     };\n  //   }\n  //   function circleEnvelopeTo(target, origin) {\n  //     const directions = circleModel.envelopeDirectionsTo(target, origin);\n  //     const envelop = {\n  //       left: {\n  //         start: circleModel\n  //           .pointOnEdgeInDirection(directions.left, origin),\n  //         end: circleModel\n  //           .pointOnEdgeInDirection(directions.left, target)\n  //       },\n  //       right: {\n  //         start: circleModel\n  //           .pointOnEdgeInDirection(directions.right, origin),\n  //         end: circleModel\n  //           .pointOnEdgeInDirection(directions.right, target)\n  //       }\n  //     };\n  //     return envelop;\n  //   }\n  //   function circleOutsideEnvelopeTo(target,\n  //                                    intervenings,\n  //                                    origin) {\n  //     const directions = circleModel.envelopeDirectionsTo(target, origin);\n  //     const envelope = {\n  //       left: findLeftEnvelopeLine(directions, target, intervenings, origin),\n  //       right: findRightEnvelopeLine(directions, target, intervenings, origin)\n  //     };\n  //     envelope.left.vector = lineModel.vector(envelope.left);\n  //     envelope.right.vector = lineModel.vector(envelope.right);\n\n  //     const outside_envelope = {\n  //       left: {\n  //         start: { x: envelope.left.end.x, y: envelope.left.end.y }\n  //       },\n  //       right: {\n  //         start: { x: envelope.right.end.x, y: envelope.right.end.y }\n  //       }\n  //     };\n  //     const translate_left = 800;\n  //     const translate_right = 800;\n  //     const vector_product = pointModel\n  //           .vectorProduct(envelope.left.vector, envelope.right.vector);\n  //     if(vector_product > 0.001) {\n  //       const envelope_end = {\n  //         start: envelope.left.end,\n  //         end: envelope.right.end\n  //       };\n  //       envelope_end.length = lineModel.length(envelope_end);\n  //       envelope_end.vector = lineModel.vector(envelope_end);\n\n  //       const alpha = Math.acos(pointModel.scalarProduct(envelope_end.vector,\n  //                                                        envelope.left.vector));\n  //       const beta = Math.acos(-pointModel.scalarProduct(envelope_end.vector,\n  //                                                        envelope.right.vector));\n  //       translate_left = envelope_end.length * Math.sin(alpha) / Math.sin(alpha+beta);\n  //       translate_right = envelope_end.length * Math.sin(beta) / Math.sin(alpha+beta);\n  //     }\n  //     translate_left = Math.min(800, translate_left);\n  //     translate_right = Math.min(800, translate_right);\n  //     outside_envelope.left.end = pointModel\n  //       .translateInVector(translate_left, envelope.left.vector,\n  //                          outside_envelope.left.start);\n  //     outside_envelope.right.end = pointModel\n  //       .translateInVector(translate_right, envelope.right.vector,\n  //                          outside_envelope.right.start);\n  //     return outside_envelope;\n  //   }\n  //   function findLeftEnvelopeLine(directions, target, intervenings, origin) {\n  //     const rad_inc = (directions.right - directions.left) / 180;\n  //     const ray = {\n  //       start: null,\n  //       end: null\n  //     };\n  //     for(let ray_rad = directions.left ;\n  //         ray_rad < directions.right ;\n  //         ray_rad += rad_inc) {\n  //       ray.start = circleModel.pointOnEdgeInDirection(ray_rad, origin);\n  //       ray.end = circleModel.pointOnEdgeTangentTo(ray.start, true, target);\n  //       ray.length = lineModel.length(ray);\n  //       ray.vector = lineModel.vector(ray);\n\n  //       const intervening = R.find((circle) => {\n  //         return circleModel.intersectLine(ray, circle);\n  //       }, intervenings);\n\n  //       if(R.isNil(intervening)) return ray;\n  //     }\n  //     return ray;\n  //   }\n  //   function findRightEnvelopeLine(directions, target, intervenings, origin) {\n  //     const rad_inc = (directions.right - directions.left) / 180;\n  //     const ray = {\n  //       start: null,\n  //       end: null\n  //     };\n  //     for(let ray_rad = directions.right ;\n  //         ray_rad > directions.left ;\n  //         ray_rad -= rad_inc) {\n  //       ray.start = circleModel.pointOnEdgeInDirection(ray_rad, origin);\n  //       ray.end = circleModel.pointOnEdgeTangentTo(ray.start, false, target);\n  //       ray.length = lineModel.length(ray);\n  //       ray.vector = lineModel.vector(ray);\n\n  //       const intervening = R.find((circle) => {\n  //         return circleModel.intersectLine(ray, circle);\n  //       }, intervenings);\n\n  //       if(R.isNil(intervening)) return ray;\n  //     }\n  //     return ray;\n  //   }\n  // }\n})();\n"]}