{"version":3,"sources":["random.es6"],"names":[],"mappings":";;AAAA,EAAE,MAAF,GAAW,YAAO;AAChB,MAAI,SAAS,SAAT,MAAS,CAAS,GAAT,EAAc,GAAd,EAAmB;AAC9B,QAAI,OAAO,CAAP,CAD0B;AAE9B,QAAI,QAAQ,MAAM,GAAN,CAFkB;;AAI9B,QAAI,cAAc,EAAE,MAAF,CAAS,KAAK,IAAL,CAAT,GAAsB,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,KAAV,CAAV,CAAtB,GAAoD,EAApD,CAJY;AAK9B,QAAI,cAAc,EAAd,EAAkB;AACpB,YAAM,IAAI,KAAK,SAAL,CAAe,iDAAnB,CAAN,CADoB;KAAtB;AAGA,QAAI,eAAe,KAAK,IAAL,CAAU,cAAc,CAAd,CAAzB,CAR0B;AAS9B,QAAI,OAAO,KAAK,GAAL,CAAS,CAAT,EAAY,WAAZ,IAA2B,CAA3B;;;;AATmB,QAa1B,YAAY,IAAI,UAAJ,CAAe,YAAf,CAAZ,CAb0B;AAc9B,SAAK,MAAL,CAAY,eAAZ,CAA4B,SAA5B,EAd8B;;AAgB9B,QAAI,IAAI,CAAC,eAAe,CAAf,CAAD,GAAqB,CAArB,CAhBsB;AAiB9B,SAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,YAAJ,EAAkB,GAAlC,EAAuC;AACrC,cAAQ,UAAU,CAAV,IAAe,KAAK,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAf,CAD6B;AAErC,WAAK,CAAL,CAFqC;KAAvC;;;AAjB8B,QAuB9B,GAAO,OAAO,IAAP,CAvBuB;;AAyB9B,QAAI,QAAQ,KAAR,EAAe;;AAEjB,aAAO,OAAO,GAAP,EAAY,GAAZ,CAAP,CAFiB;KAAnB;;AAzB8B,WA8BvB,MAAM,IAAN,CA9BuB;GAAnB,CADG;AAiChB,SAAO,YAAM;AACX,WAAO,OAAO,CAAP,EAAU,UAAV,IAAwB,UAAxB,CADI;GAAN,CAjCS;CAAN,EAAZ;;AAsCA,EAAE,WAAF,GAAgB,UAAS,GAAT,EAAc,GAAd,EAAmB;AACjC,SAAQ,GAAE,GAAM,EAAE,MAAF,MAAc,MAAM,GAAN,GAAY,CAAZ,CAAd,GAA+B,CAAvC,CADyB;CAAnB;;AAIhB,EAAE,IAAF,GAAS,YAAW;AAClB,SAAO,uCAAuC,OAAvC,CAA+C,OAA/C,EAAwD,UAAS,CAAT,EAAY;AACzE,QAAI,IAAI,EAAE,MAAF,KAAa,EAAb,GAAkB,CAAlB;QACJ,IAAI,KAAK,GAAL,GAAW,CAAX,GAAgB,IAAI,GAAJ,GAAU,GAAV,CAFiD;AAGzE,WAAO,EAAE,QAAF,CAAW,EAAX,CAAP,CAHyE;GAAZ,CAA/D,CADkB;CAAX","file":"random.js","sourcesContent":["R.random = (() => {\n  var random = function(min, max) {\n    var rval = 0;\n    var range = max - min;\n    \n    var bits_needed = R.exists(Math.log2) ? Math.ceil(Math.log2(range)) : 30;\n    if (bits_needed > 53) {\n      throw new self.Exception('We cannot generate numbers larger than 53 bits.');\n    }\n    var bytes_needed = Math.ceil(bits_needed / 8);\n    var mask = Math.pow(2, bits_needed) - 1;\n    // 7776 -> (2^13 = 8192) -1 == 8191 or 0x00001111 11111111\n    \n    // Create byte array and fill with N random numbers\n    var byteArray = new Uint8Array(bytes_needed);\n    self.crypto.getRandomValues(byteArray);\n    \n    var p = (bytes_needed - 1) * 8;\n    for (var i = 0; i < bytes_needed; i++) {\n      rval += byteArray[i] * Math.pow(2, p);\n      p -= 8;\n    }\n    \n    // Use & to apply the mask and reduce the number of recursive lookups\n    rval = rval & mask;\n    \n    if (rval >= range) {\n      // Integer out of acceptable range\n      return random(min, max);\n    }\n    // Return an integer that falls within the range\n    return min + rval;\n  };\n  return () => {\n    return random(0, 1000000000) / 1000000000;\n  };\n})();\n\nR.randomRange = function(min, max) {\n  return (( min + R.random() * (max - min + 1) )|0);\n};\n\nR.guid = function() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = R.random() * 16 | 0,\n        v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n};\n"]}